Today I'm going to be talking to you about declarative programming as it relates to user interfaces, the QML language which implements these declarative ideas and my own project HQML which sits on top of QML.

So first, what is declarative programming? The very short answer is that it is telling your machine what you want, not what to do. This can be contrasted directly to imperative programming, in which you must guide the computer through each step to achieve your goals.
Instead you state the goals of your program and allow the runtime / framework / library reason about the best way to achieve them.
This is useful in a number of domains - some of which you will have certainly used before, such as SQL - but today I'll be talking about a domain where I believe it's not only useful but a required part of your toolkit: user interfaces.

Let's start with an extremely simple example to highlight the differences between the declarative and imperative approach.
The requirements for our program are simple - we need a block level element containing two inline elements which have the words 'hello' and 'world' in them respectively, separated by a space.
Here are two approaches that achieve the spec, one simply says what we want, the other goes into quite a bit of detail as to how to create our document tree.
Even though it's unlikely you'd ever write code like this in real life, let's go over the comparative benefits of the declarative version as we'll soon see they apply across the board in a more real world example.

The first benefit is quite simple - the HTML is a lot more to the point. There's a lot more room to introduce bugs due to the verbosity of the imperative code, and the fact it's doing more work - for example retaining a bunch of references to the divs and spans before constructing the tree.
Related to that is the time both to create the interface and iterate changes. When it comes time to update the interface and change something I know which code I'd rather be presented with.
One of the nicest features of declarative code is that it's quite simple to determine the intent with which it was written. In fact if you read that HTML snippet out loud you'll basically get back the spec I gave to you. For the imperative code you basically have to step through it in your head to see what its doing, which doesn't tend to scale very well. When you really get into declarative programming you'll start to notice it's a lot less context dependent than imperative code, which helps on this point as well.
I'll talk about the UI staying in sync shortly - it's the biggest benefit for more complex UIs.

(no slide) Hopefully at this point you're thinking that there's no way you'd write JavaScript like in this example, that it's obviously inferior and I'm just wasting your time treading over the benefits of HTML over JavaScript for simple UIs. But I've written code as bad as this, every web developer I've worked with has written code like this, and I'd be willing to bet anyone in this room who's built a UI has written code like this. In the web world in particular it's not immediately obvious that there's a better way too. So let's get straight to an example that shows what I mean.

You can see here we've got a simple sign up form, the only prerequisite is that you accept the terms and conditions to be allowed in. If you don't, the server's simply going to re-serve the page, maybe with a little error box. To improve the user experience, your boss / client / whoever says that the button should not be clickable while the checkbox is empty.

The instinct here is to attach a handler to the checkbox change event which sets the state of the submit button. Using jQuery we can keep the code fairly terse, and smooth over browser compatibility issues. Additionally it adheres to the apparent best practice of separating content from behaviour. However, to me, this approach is completely wrong, and brings with it all the same issues as the imperative div making code we saw before.

(no slide) Specifically, I see these problems with the code. The key relationship we're trying to model is 1 out of 6 lines here, the rest could just be seen as boilerplate. And that relationship is pretty awkwardly expressed. It also relies on understanding how jQuery assigns 'this' in events which is cognitive overhead we could do without. Then there's the fact that the assignment isn't really portable - it has to run in the document onload event and so is harder to abstract out to a separate component if desired. Additionally, we're required to separately set the initial value away from the event handler. You can also see the markup has been modified to add ids to the form elements so we can find them with jQuery. If it sounds like I'm nitpicking at this point, just remember that a single application can run into thousands of these interactions and constraints. Writing code in this fashion will become a problem sooner rather than later.

So, if jQuery is out, what would be our ideal solution? Obviously since this presentation is about declarative UIs, there's a pretty big clue. We want to tell the browser what we want and let it figure out the rest. So here's an example implementation that does just that. Compared to our initial non-interactive form, this has just two extra attributes and no separate JavaScript at all. One is simply an id on the checkbox, the other is defining the relationship between the disabled status of the button and the checkbox. So here we're simply pretending that instead of the presence or absence of the disabled attribute determining the state of the button, it instead takes an expression which will be evaluated to determine whether the button is enabled. Most importantly, in this implementation the expression will be re-evaluated whenever tandc.checked is updated, keeping everything in sync.

So how close can we get to this ideal? Surprisingly the answer is quite close indeed. Here is a working implementation in declarative style using the Knockoutjs framework, which provides an implementation of the observable pattern and dom bindings which work together to make writing declarative interfaces quite straightforward. As you can see it uses the idea of expressions in HTML attributes, in this case in Knockout's custom data-bind attribute. The 'checked' binding allows the checkbox to control the value of termsAccepted, and the 'enabled' binding allows the button status to react to those updates. The only work remaining is to actually create the termsAccepted observable variable, and to kick the bindings off.

Now we're going to kick it up a notch to reveal the major strong points of writing your UI in a declarative style: state management in large projects. I'm going to build on this same form example, but for the next few slides I want you to think about large apps with hundreds of user actions and the thousands, maybe millions of paths users can take to modify the state of the interface. For now we'll just add one new interaction: the product you're working on now comes in two flavours, hobbyist and enterprise. It's your job to add some radio buttons so the user can choose one on sign up. Your boss tells you that because these plans have different terms and conditions, if the user accepts the terms but then changes between hobby and enterprise you have to clear the checkbox.

Let's look at the imperative solution first - you can see the extra markup added for the radios and the new JavaScript in it's entirety. The code is implemented as a nearly literal interpretation of the spec given by the boss, but he probably won't be happy with it. Can anyone spot the bug? That's right - changing the radio option selected will clear the checkbox, but the button will stay enabled. Because changing the checkbox state in code doesn't fire the onchange event, your interface is now what I call 'out of sync'. This type of bug arises all the time in imperative interfaces, and can be quite difficult to detect as complexity grows. In fact any user interaction path not manually tested could quite easily hide problems like this.

(no slide) There's a number of roads you could go down from here to fix this, none of them are particularly elegant though. The worst, but in my experience most common, is that the event handler for the radio change could also set the button to disabled. As complexity grows, this basically means all components need to know about all others and you have extreme fragility and tight coupling. Avoid like the plague. A more reasonable option is to not have anonymous functions as handlers but to define them elsewhere, then call one from another as required. This is still an example of tight coupling though - each interaction needs to know which other functions to call based on its side effects. Another option still is to avoid individual handlers all together an send every event to an 'update' function which reads every piece of relevant state and rebuilds your UI state as required. This approach is actually bordering on declarative - if you've used the d3 graph library that's a good example - but without a lot of forethought is not going to be optimal.

(no slide) So you can see that even with only 2 very simple interactions we're already in a bit of a pickle. I don't think I'm being unreasonable to suggest that imperative code just isn't up to scratch for complex user interfaces. Here's how the Knockout version looks.

As you can see we've added the exact same markup as the jQuery based solution, except Knockout encourages adding 'one-line' type events inline. The handler just sets termsAccepted to false exactly as the boss asked. This will clear the checkbox if required and set the submit button to disabled along with it. Because we've declared the controls to be bound to termsAccepted, the runtime will make it so. That's the real power of declaratively writing interfaces.

(no slide) Now that you're acquainted with the idea of declarative interfaces, I'd like to change tracks now to the desktop world where there's a bit more choice than just syntax bolted on to HTML. Whilst there are now multiple frameworks which provide declarative semantics for user interfaces, I'm going to focus on a favourite of mine: QML.

QML is part of the Qt framework designed for exactly the type of declarative UIs I've been describing. It provides both a runtime and library of objects ready to use. The markup itself looks a bit like CSS and JavaScript combined together, with JSON style object nesting. The reason for this is that QML makes no attempt to separate content, presentation and behaviour as with HTML / CSS / JavaScript. When you do need more firepower than just binding expressions to properties, QML has a full JavaScript interpreter you can use.

To put this all in more concrete terms, let's have a look at our sign up form as implemented in QML. After importing a few of the available modules, you can see the nested object structure straight away. On the top level is the app window, with its own properties. The height of the window is bound to a function on the width, maintain a nice 4:3 ratio as the user resizes the window. Inside that is a Column object which automatically lays out it's child objects. Then the group the radio buttons belong to, which itself has a signal - when the radio selection is changed the checkbox state is set to false. Following that are the checkbox itself and a button with its enabled state bound to the checkbox.

QML provides a lot of objects out of the box, here's the top level breakdown of built-in modules. (go through list)

