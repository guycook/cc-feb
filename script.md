Today I'm going to be talking to you about declarative programming as it relates to user interfaces, the QML language which implements these declarative ideas and my own project HQML which sits on top of QML.

So first, what is declarative programming? The very short answer is that it is telling your machine what you want, not what to do. This can be contrasted directly to imperative programming, in which you must guide the computer through each step to achieve your goals.
Instead you state the goals of your program and allow the runtime / framework / library reason about the best way to achieve them.
This is useful in a number of domains - some of which you will have certainly used before, such as SQL - but today I'll be talking about a domain where I believe it's not only useful but a required part of your toolkit: user interfaces.

Let's start with an extremely simple example to highlight the differences between the declarative and imperative approach.
The requirements for our program are simple - we need a block level element containing two inline elements which have the words 'hello' and 'world' in them respectively, separated by a space.
Here are two approaches that achieve the spec, one simply says what we want, the other goes into quite a bit of detail as to how to create our document tree.
Even though it's unlikely you'd ever write code like this in real life, let's go over the comparative benefits of the declarative version as we'll soon see they apply across the board in a more real world example.

The first benefit is quite simple - the HTML is a lot more to the point. There's a lot more room to introduce bugs due to the verbosity of the imperative code, and the fact it's doing more work - for example retaining a bunch of references to the divs and spans before constructing the tree.
Related to that is the time both to create the interface and iterate changes. When it comes time to update the interface and change something I know which code I'd rather be presented with.
One of the nicest features of declarative code is that it's quite simple to determine the intent with which it was written. In fact if you read that HTML snippet out loud you'll basically get back the spec I gave to you. For the imperative code you basically have to step through it in your head to see what its doing, which doesn't tend to scale very well. When you really get into declarative programming you'll start to notice it's a lot less context dependent than imperative code, which helps on this point as well.
I'll talk about the UI staying in sync shortly - it's the biggest benefit for more complex UIs.

(no slide) Hopefully at this point you're thinking that there's no way you'd write JavaScript like in this example, that it's obviously inferior and I'm just wasting your time treading over the benefits of HTML over JavaScript for simple UIs. But I've written code as bad as this, every web developer I've worked with has written code like this, and I'd be willing to bet anyone in this room who's built a UI has written code like this. In the web world in particular it's not immediately obvious that there's a better way too. So let's get straight to an example that shows what I mean.

You can see here we've got a simple sign up form, the only prerequisite is that you accept the terms and conditions to be allowed in. If you don't, the server's simply going to re-serve the page, maybe with a little error box. To improve the user experience, your boss / client / whoever says that the button should not be clickable while the checkbox is empty.

The instinct here is to attach a handler to the checkbox change event which sets the state of the submit button. Using jQuery we can keep the code fairly terse, and smooth over browser compatibility issues. Additionally it adheres to the apparent best practice of separating content from behaviour. However, to me, this approach is completely wrong, and brings with it all the same issues as the imperative div making code we saw before.

(no slide) Specifically, I see these problems with the code. The key relationship we're trying to model is 1 out of 6 lines here, the rest could just be seen as boilerplate. And that relationship is pretty awkwardly expressed. It also relies on understanding how jQuery assigns 'this' in events which is cognitive overhead we could do without. Then there's the fact that the assignment isn't really portable - it has to run in the document onload event and so is harder to abstract out to a separate component if desired. Additionally, we're required to separately set the initial value away from the event handler. You can also see the markup has been modified to add ids to the form elements so we can find them with jQuery. If it sounds like I'm nitpicking at this point, just remember that a single application can run into thousands of these interactions and constraints. Writing code in this fashing will become a problem sooner rather than later.

So, if jQuery is out, what would be our ideal solution? Obviously since this presentation is about declarative UIs, there's a pretty big clue. We want to tell the browser what we want and let it figure out the rest. So here's an example implementation that does just that. Compared to our initial non-interactive form, this has just two extra attributes and no separate JavaScript at all. One is simply an id on the checkbox, the other is defining the relationship bewtween the disabled status of the button and the checkbox. So here we're simply pretending that instead of the presence or absence of the disabled attribute determining the state of the button, it instead takes an expression which will be evaluated to determine whether the button is enabled. Most importantly, in this implementation the expression will be re-evaluated whenever tandc.checked is updated, keeping everything in sync.

So how close can we get to this ideal? Surprisingly the answer is quite close indeed. Here is a working implementation in declarative style using the Knockoutjs framework, which provides an implementation of the obseravable pattern and dom bindings which work together to make writing declarative interfaces quite straightforward.
